Future Features & Project RoadmapThis document outlines potential future directions for this agent orchestration template. The goal of the base template is to be simple and easy to understand, but it can be extended into a more powerful and dynamic framework for complex multi-agent systems.1. Advanced Orchestration with a FrameworkThe current system uses a simple while loop in main.py and a series of if/elif statements in router_agent.py to control the workflow. This is intentional to keep the learning curve low.For more complex projects, you might want to graduate to a dedicated agent framework.Proposed Integration: lastmile-ai/mcp-agentWhat it is: A lightweight framework specifically designed to build production-ready agents that use the Model Context Protocol (MCP).Why use it?Formal Workflows: Instead of a simple loop, you can define complex, multi-step workflows in code (e.g., plan -> code -> test -> review).State Management: Frameworks handle the state between agent steps more robustly than passing file paths around.Deployment: They are designed to be wrapped in servers (e.g., FastAPI) and deployed as long-running applications.Path to Integration: Once the core logic of your agents is proven in this simple template, you can migrate them into the structure provided by a framework like mcp-agent to build a more formal application.2. Dynamic Agent Management (Plugin Architecture)A powerful evolution for this template would be to create a system where agents can be added, removed, enabled, or disabled without having to manually edit the core routing logic. This turns individual agents into "plugins" for the main system.This is how many extensible open-source projects handle contributions, allowing a community to easily add new functionality.How it WorksThe system would be re-architected to follow a discovery and registration pattern:A. Agent RegistrationEach agent file would need to export a manifest or a registration function that describes it to the system.Example: agents/planner_agent.py# ... (rest of the agent logic)

# Registration function that the main system will look for
def register():
    return {
        "command": "plan",
        "description": "Generate a spec/blueprint for a task.",
        "handler": handle_plan # The function to call
    }
B. Central ConfigurationA new configuration file, agents.yaml, would be added to the root directory to control which agents are active.Example: agents.yaml# List of agents to activate for this project
active_agents:
  - planner_agent
  - coder_agent
  - tester_agent
  # The 'reviewer_agent' is disabled for this project
  # - reviewer_agent
C. Dynamic Loading in the RouterThe router_agent.py and main.py would be rewritten to be dynamic. On startup, they would:Read agents.yaml to get the list of active_agents.Scan the /agents directory.For each active agent file, import it and call its register() function.Dynamically build a dictionary of available commands (e.g., {'plan': handle_plan, 'code': handle_code}).When a user enters a command, the router simply looks it up in the dictionary and calls the associated handler.The help text in main.py would also be generated dynamically from the "description" field of the registered agents.Benefits of a Plugin ArchitectureExtensibility: New agents can be added just by creating a new file in the /agents folder; no core code needs to change.Configurability: Users can easily turn agents on or off for specific projects by editing the .yaml file.Community Contributions: This creates a clean process for others to contribute new agents. A contributor can create a frontend_agent.py, and a user can instantly integrate it just by adding it to their agents.yaml file.